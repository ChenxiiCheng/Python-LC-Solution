# Python Solutions for Leetcode

[Python3](https://github.com/ChenxiiCheng/Python-LC-Solution) solutions list, continuing update. &hearts; means you need a subscription.

| #    | Title                                                        | Difficulty | Basic  idea                                                  | Solution                                                     |
| ---- | ------------------------------------------------------------ | :--------: | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | [Two Sum](https://leetcode.com/problems/two-sum/)            |    Easy    | 1. 暴力解法.  2.字典解法.                                    | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q1-Two%20Sum-Easy.py) |
| 2    | [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/) |   Medium   | 1. l1、l2对应位+进位位作为root.next结点.                     | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q2-Add%20Two%20Numbers-Medium.py) |
| 3    | [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/) |   Medium   | 1. 两种做法, 若s[i]在dic中且start <= dic[s[i]], 则更新start, 否则ans = max(ans, i - start + 1)    2. 若v不在dic或者即使v在dic但dic[v] < start: ans = max(ans, i - start + 1) 否则start = dic[v] + 1. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q3-Longest%20Substring%20Without%20Repeating%20Characters-Medium.py) |
| 5    | [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/) |   Medium   | 1. 对每一位字母调用help, 即以该字母为中心，向两边扩开, 条件s[l]==s[r]  2.两种情况都要考虑到, s为奇数个, s为偶数个. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q5-Longest%20Palindromic%20Substring-Medium.py) |
| 11   | [Container With Most Water](https://leetcode.com/problems/container-with-most-water/description/) |   Medium   | 1. left, right为横坐标, 两边想中间找最高的height: height[left], height[right], 每次计算下area = (right - left) * l or r, 注意while height[left] <= l就直接跳过, 右边也是, 然后更新max_area = max(max_area, area). | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q11-Container%20With%20Most%20Water-Medium.py) |
| 12   | [Integer to Roman](https://leetcode.com/problems/integer-to-roman/description/) |   Medium   | 1. letter, n in zip(lis, nums): ans += letter * (num // n)   num %= n. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q12-Integer%20to%20Roman-Medium.py) |
| 13   | [Roman to Integer](https://leetcode.com/problems/roman-to-integer/) |   Medium   | <br/>                                                        | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q13-Roman%20to%20Integer-Medium.py) |
| 15   | [Three Sum](https://leetcode.com/problems/3sum/description/) |   Medium   | 1. left, right法   2. 字典法                                 | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q15-3Sum-Medium.py) |
| 16   | [3Sum Closest](https://leetcode.com/problems/3sum-closest/description/) |   Medium   | 1. s = nums[i] + nums[left] + nums[right] ans = float('inf'), if abs(s - target) < abs(ans - target): ans = s.   2. s > target: right -= 1  3. s < target: left += 1   4. else return target. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q16-3Sum%20Closest-Medium.py) |
| 17   | [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/) |   Medium   | 1. dic字典放键盘对应str.                                     | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q17-Letter%20Combinations%20of%20a%20Phone%20Number-Medium.py) |
| 20   | [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/description/) |    Easy    | 1. replace()函数方法   2. dic={')':'(', '}':'{', ']':'['}.   | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q20-Valid%20Parentheses-Easy.py) |
| 21   | [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/description/) |    Easy    |                                                              | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q21-Merge%20Two%20Sorted%20Lists-Easy.py) |
| 24   | [Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/description/) |   Medium   | 1. 每次取出p1, p2, root.next, p1.next, p2.next = p1, p2.next, p1. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q24-Swap%20Nodes%20in%20Pairs-Medium.py) |
| 33   | [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/description/) |   Medium   | 1. 若nums[left] <= nums[mid], 左边有序, 若target在左边里, right = mid - 1, 否则left = mid + 1; nums[mid] <= nums[right]右边有序, 若target在右边里, left = mid + 1, 否则right = mid - 1. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q33-Search%20in%20Rotated%20Sorted%20Array-Medium.py) |
| 39   | [Combination Sum](https://leetcode.com/problems/combination-sum/description/) |   Medium   | 1. stack存储[(curSum, index, path)], 若弹出的curSum == target: ans.append(path)   2.for i in range(index, len(candidates)): t = curSum + candidates[i], if t > target: break, 放入stack中继续. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q39-Combination%20Sum-Medium.py) |
| 48   | [Rotate Image](https://leetcode.com/problems/rotate-image/description/) |   Medium   | 1. Zip   2. 当i < j: matrix[i] [j]和matrix[j] [i]换位置.     | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q48-Rotate%20Image-Medium.py) |
| 49   | [Group Anagrams](https://leetcode.com/problems/group-anagrams/description/) |   Medium   | 1. 把strs里每个单词sorted排序作为dic的key, 把排序后是相同的每个strs都放入dic[key]的value中, 输出dic的所有val -> return [val for val in dic.values()]. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q49-Group%20Anagrams-Medium.py) |
| 56   | [Merge Intervals](https://leetcode.com/problems/merge-intervals/description/) |   Medium   | 1. stack存储第一个interavls, 从第二个intervals开始, 判断.start是否 <= stack[-1].end | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q56-Merge%20Intervals-Medium.py) |
| 62   | [Unique Paths](https://leetcode.com/problems/unique-paths/description/) |   Medium   | 1. 动态规划dp = [[1 for _ in rangee(n)] for __ in range(m)], 对于每一个(1,m)(1,n): dp[i] [j] = dp[i - 1] [j] + dp[i] [j - 1]. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q62-Unique%20Paths-Medium.py) |
| 64   | [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/) |   Medium   | <br/>                                                        | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q64-Minimum%20Path%20Sum-Medium.py) |
| 71   | [Simplify Path](https://leetcode.com/problems/simplify-path/description/) |   Medium   | 1. 先把path中的/去掉, stack列表中存放判断出是真实的路径, 对path的每一个ch进行判断, 【1】ch in ('', '.'): pass 【2】ch == '..': 若stack存在, 则说明要跳转到这个path的前一个root path, 直接弹出stack.pop()即可 【3】ch是一个路径, 加到stack中. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q71-Simplify%20Path-Medium.py) |
| 79   | [Word Search](https://leetcode.com/problems/word-search/description/) |   Medium   | 1. if self.dfs(board, i, j, word): return True    2. 每次我们只需要递归的对这个位置的四个方向探索word[1:]即可, 注意因为是递归算法所以每次修改之后都要改回原来的值. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q79-Word%20Search-Medium.py) |
| 86   | [Partition List](https://leetcode.com/problems/partition-list/description/) |   Medium   | 1. 用两个链表, 如果head.val < x, 放入l1, 否则放入l2, 把l1, l2接起来. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q86-Partition%20List-Medium.py) |
| 102  | [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/description/) |   Medium   | 1. stack里存的是每层的所有结点  2.每次取出vals = [node.val for node in stack]放入ans中, 然后更新stack(向下继续走). | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q102-Binary%20Tree%20Level%20Order%20Traversal-Medium.py) |
| 103  | [Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/) |   Medium   | 1. stack对应每一层的所有结点, 使用reverse标志判断是否翻转每层结点组成的vals列表, 每次操作都更新reverse = not reverses. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q103-Binary%20Tree%20Zigzag%20Level%20Order%20Traversal-Medium.py) |
| 105  | [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) |   Medium   | <br/>                                                        | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q105-Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal-Medium.py) |
| 116  | [Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/) |   Medium   | 1. 若有root.left: root.left.next = root.right   2. 若有root.next: root.right.next = root.next.left. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q116-Populating%20Next%20Right%20Pointers%20in%20Each%20Node-Medium.py) |
| 121  | [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/) |    Easy    | 1. 每个price和buy = price[0]比较, 若price低, 则买入, 否则卖出. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q121-Best%20Time%20to%20Buy%20and%20Sell%20Stock-Easy.py) |
| 127  | [Word Ladder](https://leetcode.com/problems/word-ladder/description/) |   Medium   | 1. 改变word中每个位置, 判断是否满足未visited and in wordList, 一直到word == endWord结束，否则return 0. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q127-Word%20Ladder-Medium.py) |
| 138  | [Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/description/) |   Medium   | 1. 从根结点遍历, 若结点存在, 为该结点新建一个Node类对象.     | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q138-Copy%20List%20with%20Random%20Pointer-Medium.py) |
| 139  | [Word Break](https://leetcode.com/problems/word-break/description/) |   Medium   | 1. 动态规划dp, 对dp[i]=1的判断, s[i:i + l] == str(wordDict里的). | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q139-Word%20Break-Medium.py) |
| 146  | [LRU Cache](https://leetcode.com/problems/lru-cache/description/) |    Hard    | 1. collections.OrderedDict  2. Get:若key在cache中  3. Put:若key在cache; 若不在cache, 当cache满时. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q146-LRU%20Cache-Hard.py) |
| 155  | [Min Stack](https://leetcode.com/problems/min-stack/description/) |    Easy    | 1. 维护两个stack, stack2存放最小的数.                        | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q155-Min%20Stack-Easy.py) |
| 200  | [Number of Islands](https://leetcode.com/problems/number-of-islands/description/) |   Medium   | 1.每次碰到1, count += 1, 调用dfs函数把相连的1都变成0.        | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q200-Number%20of%20Islands-Medium.py) |
| 206  | [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/) |    Easy    | 1. prev初始化为None, 每次cur = head, head = head.next, cur.next = prev, prev = cur. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q206-Reverse%20Linked%20List-Easy.py) |
| 207  | [Course Schedule](https://leetcode.com/problems/course-schedule/description/) |   Medium   | 1. Graph[course] = pre, neighbors[pre] = course              | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q207-Course%20Schedule-Medium.py) |
| 210  | [Course Schedule II](https://leetcode.com/problems/course-schedule-ii/) |   Medium   | <br/>                                                        | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q210-Course%20Schedule%20II-Medium.py) |
| 211  | [Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/) |   Medium   | <br/>                                                        | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q211-Add%20and%20Search%20Word%20-%20Data%20structure%20design-Medium.py) |
| 215  | [Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/description/) |   Medium   | 1. 维护一个heap堆, 放所有nums放进去, 然后只要len(heap) > k 就heapq.heappop(heap). | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q215-Kth%20Largest%20Element%20in%20an%20Array-Medium.py) |
| 238  | [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/description/) |   Medium   | 1. 正序, output列表对应nums列表位置存的是nums该位置前面所有数的乘积   2. 倒序, output列表对应乘上nums列表该位置后面所有数的乘积. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q238-Product%20of%20Array%20Except%20Self-Medium.py) |
| 252  | [Meeting Rooms](https://leetcode.com/problems/meeting-rooms/description/) |    Easy    | 1. 若intervals[i].start < intervals[i - 1].end， 则return False. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q252-Meeting%20Rooms-Easy.py) |
| 253  | [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/description/) |   Medium   | 1. 维护一个heap, 里面放inter.end, 对每个inter, 判断heap[0] <= inter.start, 则说明这两个Interval可以共用房间, 更新inter.end即可, 否则就加入新的inter.end. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q253-Meeting%20Rooms%20II-Medium.py) |
| 284  | [Peeking Iterator](https://leetcode.com/problems/peeking-iterator/description/) |   Medium   | 1. self.n = None是一个标志, 若self.n != None时, 说明hasNext, 且self.n里存储的就是next的值. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q284-Peeking%20Iterator-Medium.py) |
| 285  | [Inorder Successor in BST](https://leetcode.com/problems/inorder-successor-in-bst/description/) |   Medium   | 1. p.val < root.val: succ = root, root = root.left else root = root.right. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q285-Inorder%20Successor%20in%20BST-Medium.py) |
| 286  | [Walls and Gates](https://leetcode.com/problems/walls-and-gates/description/) |   Medium   | 1. 切入点是每次遍历到rooms[i] [j] == 0是调用函数处理, 也就是先找到gate;   2. 在函数里若rooms[i] [j] < dist: return, 因为rooms[i] [j] < dist说明该位置是wall走不通, 然后更新rooms[i] [j] - dist, 接着向四个方向走. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q286-Walls%20and%20Gates-Medium.py) |
| 289  | [Game of Life](https://leetcode.com/problems/game-of-life/description/) |   Medium   | 1. 对于每个位置调用dfs()函数, dfs函数用来找当前位置周围8个位置, 若有1, 则count += 1 | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q289-Game%20of%20Life-Medium.py) |
| 322  | [Coin Change](https://leetcode.com/problems/coin-change/description/) |   Medium   | 1. 动态规划dp, 索引是能组成的金额, 值是有多少种组成这个金额的组合法   2. dp[i] = min(dp[i], dp[i - coin] + 1). | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q322-Coin%20Change-Medium.py) |
| 323  | [Number of Connected Components in an Undirected Graph](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/) |   Medium   | <br/>                                                        | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q323-Number%20of%20Connected%20Components%20in%20an%20Undirected%20Graph-Medium.py) |
| 325  | [Maximum Size Subarray Sum Equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/description/) |   Medium   | 1. 类似two sum中的字典法, 每次curSum += nums[i], 判断curSum - k in dic, 在的话说明字典里记录的那个sum(maybe几个数的sum)刚好和这个数相加是==target的, 更新长度. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q325-Maximum%20Size%20Subarray%20Sum%20Equals%20k-Medium.py) |
| 328  | [Odd Even Linked List](https://leetcode.com/problems/odd-even-linked-list/) |   Medium   | <br/>                                                        | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q328-Odd%20Even%20Linked%20List-Medium.py) |
| 347  | [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/description/) |   Medium   | 1. collections.Counter(nums)   2.sorted排序, key=lambda x:x[1] | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q347-Top%20K%20Frequent%20Elements-Medium.py) |
| 348  | [Design Tic-Tac-Toe](https://leetcode.com/problems/design-tic-tac-toe/description/) |   Medium   | 1. addNum = 1if player == 1 else -1, 每行/每列/对角线/反对角线 进行判断是否==self.size. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q348-Design%20Tic-Tac-Toe-Medium.py) |
| 362  | [Design Hit Counter](https://leetcode.com/problems/design-hit-counter/description/) |   Medium   | 1. 维护一个队列, if timestamp - self.queue[0] >= 300: self.queue.popleft(). | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q362-Design%20Hit%20Counter-Medium.py) |
| 373  | [Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/) |   Medium   | 1. 先固定nums2[0], 把nums1中每个数和nums2[0]结合放堆中, 最小的结合肯定是nums1[0], nums2[0], 只要heap and k > 0, 弹出curSum, i, j, 然后再变j, nums1[i] + nums2[j + 1]. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q373-Find%20K%20Pairs%20with%20Smallest%20Sums-Medium.py) |
| 380  | [Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/description/) |   Medium   | 1. nums列表存储数, pos字典数和它对应的索引位置.   2. remove时, 只需把nums最后一个数和要删除的那个数调换位置, 然后nums.pop(), pos.pop(val)即可. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q380-Insert%20Delete%20GetRandom%20O(1)-Medium.py) |
| 387  | [First Unique Character in a String](https://leetcode.com/problems/first-unique-character-in-a-string/description/) |    Easy    | 1. 用dic来存储每个字母出现的次数, 因为题目要没重复的字母的索引, 用range(len(s)), 从左往右, 判断dic[s[i]] == 1, 若存在直接return i. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q387-First%20Unique%20Character%20in%20a%20String-Easy.py) |
| 445  | [Add Two Numbers II](https://leetcode.com/problems/add-two-numbers-ii/description/) |   Medium   | 1. 这道题和Q2不同之处在于Q2给的数据是已经倒序的了, 所以直接相加, 放入链表中就行, 这道题我们自己弄成倒序, 用列表pop()即可    2. 新的结点要插入到上一个结点左边, cur = ListNode(vals % 10), cur.next = root.next, root.next = cur. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q445-Add%20Two%20Numbers%20II-Medium.py) |
| 449  | [Serialize and Deserialize BST](https://leetcode.com/problems/serialize-and-deserialize-bst/description/) |   Medium   | 1. TreeNode -> str时, 把每个root.val放入ans, stack记录这个root, 然后向下继续走   2. str -> TreeNode时, data[0]根root, 向下走. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q449-Serialize%20and%20Deserialize%20BST-Medium.py) |
| 490  | [The Maze](https://leetcode.com/problems/the-maze/description/) |   Medium   | 1. 每次走要判断下是否在边界内和maze[r + i] [c + j] != 1.     | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q490-The%20Maze-Medium.py) |
| 505  | [The Maze II](https://leetcode.com/problems/the-maze-ii/description/) |   Medium   | 1. visited = {(start[0], start[1]): 0}存放的是从起点到这点的距离, q = [(0, start[0], start[1])]存放的是这点到起点距离, 这点的位置, 区别是visited是记录走过的路, 并且当dist + d < visited[(r, c)]要更新. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q505-The%20Maze%20II-Medium.py) |
| 543  | [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/description/) |    Easy    | 1. self.ans = max(self.ans, left + right)   2. depth()函数return 1 + max(left, right). | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q543-Diameter%20of%20Binary%20Tree-Easy.py) |
| 545  | [Boundary of Binary Tree](https://leetcode.com/problems/boundary-of-binary-tree/description/) |   Medium   | <br/>                                                        | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q545-Boundary%20of%20Binary%20Tree-Medium.py) |
| 556  | [Next Greater Element III](https://leetcode.com/problems/next-greater-element-iii/description/) |   Medium   | 1. 这道题和前面一道题同源, 不同点是之前那道题给的数据是['1', '2', '3']这样的形式, 所以这里先把nums = list(str(n)), 再按照之前的解法就行. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q556-Next%20Greater%20Element%20III-Medium.py) |
| 658  | [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/description/) |   Medium   | 1. 列表pop()    2. 二分法找左边界, 输出arr[left:left + k].   | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q658-Find%20K%20Closest%20Elements-Medium.py) |
| 694  | [Number of Distinct Islands](https://leetcode.com/problems/number-of-distinct-islands/description/) |   Medium   | 1. 维护一个全局self.steps = '', 对于每个grid[i] [j] == 1, 调用dfs()函数, self.steps记录路径. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q694-Number%20of%20Distinct%20Islands-Medium.py) |
| 703  | [Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/description/) |    Easy    | 1. 维护一个长度为K的堆，题目需要的Kth就是堆顶那个数, python中只有最小堆(如果需要最大堆,把他转成 '-最小堆'). | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q703-Kth%20Largest%20Element%20in%20a%20Stream-Easy.py) |
| 733  | [Flood Fill](https://leetcode.com/problems/flood-fill/description/) |    Easy    | 1. 判断当前image[i] [j]是否和newColor一样，弱不一样则调用dfs()函数, dfs()函数把当前color改成newColor,同时向周围走,周围image[i] [j] == 旧color的, 都改成newColor. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q733-Flood%20Fill-Easy.py) |
| 819  | [Most Common Word](https://leetcode.com/problems/most-common-word/description/) |    Easy    | 1. 双索引从句子中取出单词, dic记录word对应出现次数.          | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q819-Most%20Common%20Words-Easy.py) |
| 937  | [Reorder Log Files](https://leetcode.com/problems/reorder-log-files/description/) |    Easy    | 1. 对每个log分割, 判断log[1].isalpha(), 是的话放到letters列表, 不是则放到nums列表, letters排序, 再组合成原样输出. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q937-Reorder%20Log%20Files-Easy.py) |
| 957  | [Prison Cells After N Days](https://leetcode.com/problems/prison-cells-after-n-days/description/) |   Medium   | 1. 循环是N = 14, 每一天构造一个tmp=[0] * len(cells), 若cells[i - 1] == cells[i + 1], tmp[i] = 1. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q957-Prison%20Cells%20After%20N%20Days-Medium.py) |
| 973  | [K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/description/) |   Medium   | 1. Sorted(key=dist)排序   2.维护一个最小堆, (-dist, points[i]), 每次添加判断是否超过K个. | [Python](https://github.com/ChenxiiCheng/Python-LC-Solution/blob/master/Q973-K%20Closest%20Points%20to%20Origin-Easy.py) |

